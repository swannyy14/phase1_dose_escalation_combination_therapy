---
title: "Use Instructions"
format: html
---

# Introduction

This notebook goes over how to simulate PO-TITE-CRM. Either create a new notebook file (`*.rmd` or `*.qmd` works) or copy this notebook and follow instuctions.

# How to Use

It's recomended that you install and load the following packages.

```{r}
if (!requireNamespace("tidyverse", quietly = TRUE)) {
  install.packages("tidyverse")
  library(tidyverse)
}

if (!requireNamespace("nnet", quietly = TRUE)) {
  install.packages("nnet")
  library(nnet)
}
```

Functions about PO_TITE_CRM are in `R/po_tite_crm.R`. Functions about generating matrices are in 
`R/generate_mat.R` so you can run the following code to load all the functions.

```{r}
source("R/po_tite_crm.R")
source("R/generate_mat.R")
```

For running simulation, you need the following:

1. Vector with true toxicity probabilities (`true_tox_vec`). This contains the true probability of DLT of K dose levels.

2. Matrix of partial ordering (`po_mat`). Each row corresponds to ordering of K doses. For each row, the entry corresponds to the index of the dose level represented in the true toxicity probability vector. Number of partial ordering can be arbitrary. If there's only one ordering, then PO-TITE-CRM reduces to TITE-CRM.

3. Vector of skeletons (`skeleton_vec`) for one partial ordering. For a single partial ordering, prior toxicity probability is assigned for each dose level. The probabilities in each row should be monotonically increasing. The matrix of skeletons can be generate using `generate_skeleton_mat` according to the generated matrix of partial ordering (`po_mat`)

4. Target toxicity probability (`target_pt`). Max toxicity probability that will be tolerated.

5. Max patients (`max_patients`). Total number of patients to accrue.

```{r}
# true toxicity matrix
true_tox_mat <- matrix(c(
  0.05, 0.09, 0.13, 
  0.15, 0.2 , 0.25,
  0.29, 0.32, 0.35
  ), byrow = TRUE, nrow = 3, ncol = 3)
true_tox_vec <- dlt_mat_to_vec <- as.vector(true_tox_mat)
names(true_tox_vec) <- c("P0.5+H2", "P0.5+H3", "P0.5+H5", 
                         "P0.75+H2", "P0.75+H3", "P0.75+H5",
                         "P1.0+H2", "P1.0+H3", "P1.0+H5")
print("True toxicity probability vector:")
print(true_tox_vec)

# matrix of dose grid and partial ordering
dose_grid <- generate_dose_grid(true_tox_mat)
#po_mat <- generate_orderings_matrix(dose_grid)

nr <- nrow(dose_grid)
nc <- ncol(dose_grid)
total <- nr * nc
po_mat <- matrix(NA, nrow = 6, ncol = total)
po_mat[1,] = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
po_mat[2,] = c(1, 4, 7, 2, 5, 8, 3, 6, 9)
po_mat[3,] = c(1, 2, 4, 3, 5, 7, 6, 8, 9)
po_mat[4,] = c(1, 4, 2, 7, 5, 3, 8, 6, 9)
po_mat[5,] = c(1, 2, 4, 7, 5, 3, 6, 8, 9)
po_mat[6,] = c(1, 4, 2, 3, 5, 7, 8, 6, 9)

print("Partial ordering matrix:")
print(po_mat)

# matrix of skeleton corresponding for each partial ordering
skeleton_vec <- c(0.05, 0.08, 0.10, 0.13, 0.15, 0.18, 0.22, 0.25, 0.35)
skeleton_mat <- generate_skeleton_mat(po_mat, skeleton_vec)

skeleton_df <- as.data.frame(skeleton_mat)
colnames(skeleton_df) <- names(true_tox_vec)
skeleton_df
```

`begin_sim()` runs a single simulation given the configuration. This function doesn't have to be directly used, but is useful for checking that the variables are set up correctly.

This function returns a list. `data` contains the patient level data, such as enrollment date, what dose (index corresponding to `true_tox_vec`) they were assigned, whether they experienced DLT, and the time to toxicity.

```{r}
sim_result <- begin_sim(
  true_tox_vec = true_tox_vec,
  po_mat = po_mat,
  skeleton_mat = skeleton_mat,
  target_pt = 0.25,
  max_patients = 25,
  verbose = FALSE
)

print(sim_result)
```

`simulate_trials()` is used to run the simulation `N` times. This function returns operating characteristics of the design using the output of `begin_sim()` function. It's suggested that you edit the function directly to report characteristics of interest.

```{r}
simulate_trials <- function(
    true_tox_vec,
    po_mat,
    skeleton_mat,
    target_pt = 0.25,
    N = 100,
    verbose = FALSE
) {
  operating_char <- list(
    MTD = integer(N),
    n_enrolled = integer(N),
    adverse_event_rate = numeric(N)
  )
  
  for (i in 1:N) {
    sim_data <- begin_sim(
      true_tox_vec = true_tox_vec,
      po_mat = po_mat,
      skeleton_mat = skeleton_mat,
      target_pt = 0.25,
      verbose = verbose
    )
    
    operating_char[["MTD"]][i] <- sim_data$MTD
    operating_char[["n_enrolled"]][i] <- sim_data$n_enrolled
    operating_char[["adverse_event_rate"]][i] <- mean(sim_data$data$tox)
    operating_char[["n_adverse_events"]][i] <- sum(sim_data$data$tox, na.rm = TRUE)
  }
  
  return(operating_char)
}


op_char <- simulate_trials(
  true_tox_vec = true_tox_vec,
  po_mat = po_mat,
  skeleton_mat = skeleton_mat,
  target_pt = 0.25,
  N = 100,
  verbose = FALSE
)

# table of selected MTD
print(table(op_char$MTD))
# average number of DLTS
print(mean(op_char$n_adverse_events))
```

`dfcrm` can be used to compare the PO-TITE-CRM method above to TITE-CRM method.

```{r}
if (!requireNamespace("dfcrm", quietly = TRUE)) {
  install.packages("dfcrm")
  library(dfcrm)
}

po_index <- 3
trueprob <- true_tox_vec[po_mat[po_index,]]
prior <- skeleton_mat[po_index,]
target <- 0.25
n <- 25
x0 <- c(1,1,1,2,2,4,4,3,3,5,5,6,6,9,9)
nsim <- 1000
obswin <- 56
tgrp <- 30
rate <- 1.5
accrual <- "fixed"

myout <- titesim(
  PI = trueprob, prior = prior, target = 0.25, n = n, x0 = 1,
  nsim = nsim, obswin = obswin, tgrp = tgrp, rate = rate, accrual = accrual,
  seed = 123, restrict = FALSE
)
```



