---
title: "PO-TITE-CRM"
format: html
---

```{r}
library(tidyverse)
library(nnet)
```

[PO-CRM Original Paper](https://pmc.ncbi.nlm.nih.gov/articles/PMC3141101/)
[Following paper has more information on the first stage](https://journals.sagepub.com/doi/10.1177/1740774511408748?url_ver=Z39.88-2003&rfr_id=ori:rid:crossref.org&rfr_dat=cr_pub%20%200pubmed)

- check section called "Allocation algorithm on the first stage"

[Paper on pocrm R package](https://pmc.ncbi.nlm.nih.gov/articles/PMC3775989/#R1)

Treatment doses:

PARP-inhibitor doses: 0.5, 0.75, 1

HDAC-inhibitor doses: 2, 3, 5

Construct the matrix for true toxicity probability such that column corresponds to PARPi and row corresponds to HDACi.

A vector version of this will be columns stacked on top of each other

```{r}
# true toxicity matrix
true_tox_mat <- matrix(c(
  0.05, 0.09, 0.13, 
  0.15, 0.2 , 0.25,
  0.29, 0.32, 0.35
  ), byrow = TRUE, nrow = 3, ncol = 3)
true_tox_vec <- dlt_mat_to_vec <- as.vector(true_tox_mat)
names(true_tox_vec) <- c("P0.5+H2", "P0.5+H3", "P0.5+H5", 
                         "P0.75+H2", "P0.75+H3", "P0.75+H5",
                         "P1.0+H2", "P1.0+H3", "P1.0+H5")
print(true_tox_vec)
```

We will have $M$ partial orderings, save this to `po_mat`. This is an $M \times K$ matrix, where $M$ is the number of partial orderings and $K$ is the number of possible treatment combinations. Each entry in `po_mat` corresponds to the index of treatment combination represented by `true_tox_vec`.

```{r}
# number of partial orderings
M <- 3
# Number of treatment combinations
K <- length(true_tox_vec)

# matrix of partial ordering
po_mat <- matrix(NA, nrow = M, ncol = K)
po_mat[1,] <- c(1,2,3,4,5,6,7,8,9)
po_mat[2,] <- c(1,4,7,2,5,8,3,6,9)
po_mat[3,] <- c(1,2,4,3,5,7,6,8,9)

print(po_mat)

# matrix of skeleton corresponding for each partial ordering
skeleton_mat <- matrix(
  rep(c(0.05, 0.08, 0.10, 0.13, 0.15, 0.18, 0.22, 0.25, 0.35), 3),
  nrow = M, ncol = K, byrow = TRUE
)
print(skeleton_mat)
```

Now we need the enrolling patient data. For simplicity assume that patients are accrued at the start of the month.
We will enroll at most $N$ patients.

```{r}
# enroll next patient based on recommended dose
enroll_patient <- function(
    patient_data,
    enrollment_date,
    assigned_dose,
    true_tox_vec,
    n = NULL,
    verbose = FALSE
) {
  n_enrolled <- patient_data$n_enrolled
  
  if (is.null(n)) {
    if (n_enrolled == (nrow(patient_data$data) - 1)) {
      n <- 1
    } else {
      n <- sample(c(1,2), 1)
    }
  }
  
  for (i in 1:n) {
    if (verbose) 
      print(paste0(
        "Enrolling new patient: date - ", enrollment_date,
        ", dose - ", assigned_dose,
        ", toxic prob - ", true_tox_vec[assigned_dose])
      )
    patient_data$data[n_enrolled + i, "enrollment_date"] <- enrollment_date
    patient_data$data[n_enrolled + i, "dose_assignment"] <- assigned_dose
    tox <- rbinom(1, 1, true_tox_vec[assigned_dose])
    patient_data$data[n_enrolled + i,"tox"] <- tox
    if (tox == 1) {
      patient_data$data[n_enrolled + i,"time_to_tox"] <- sample(56, 1)
    } else {
      patient_data$data[n_enrolled + i,"time_to_tox"] <- 0
    }
  }
  
  patient_data$n_enrolled <- n + patient_data$n_enrolled
  
  return(patient_data)
}
```

```{r}
N <- 25

# patient_data is a list of the data frame and number enrolled
patient_data <- list(
  data = data.frame(
    patient_id = seq(1, N),
    enrollment_date = NA,
    dose_assignment = NA,
    tox = NA,
    time_to_tox = NA
  ),
  n_enrolled = 0
)


cur_date <- 0
patient_data <- enroll_patient(patient_data, cur_date, 2, true_tox_vec)
print(patient_data)
```

Suppose we have accumulated up to L patients. We want to get MLE for each partial ordering and select the partial ordering with highest maximum likelihood.

Following functions calculate the log likelihood with weights given for each patient.

```{r}
calc_log_lik <- function(a, response, alph, weights) {
  # calculate likelihood
  
  # a: parameter to be estimated
  # response: a vector of response for enrolled patients
  # alph: vector of skeleton probability corresponding to dose assigned to each patient
  # weights: weights associated with each patient
  
  sum(response*a*log(alph) +
        (1-response)*log(1 - weights*(alph)^a))
}

optimize_log_lik <- function(response, alph, weights) {
  # find a that maximizes the likelihood
  
  a_mle <- optimize(
    f = calc_log_lik, interval = c(0, 100),
    response = response,
    alph = alph,
    weights = weights,
    maximum = TRUE
  )
  
  return(a_mle)
}

calc_weight <- function(current_time, followup_time) {
  return(min(current_time, followup_time))
}

```


```{r}
get_next_dose_po_tite_crm <- function(
    patient_data,
    current_date,
    po_mat,
    skeleton_mat,
    target_pt = 0.25
) {
  n_enrolled <- patient_data$n_enrolled
  M <- nrow(po_mat)
  
  # get the response and weights as vectors
  response <- patient_data$data$tox[1:n_enrolled]
  tox_time <- patient_data$data$time_to_tox[1:n_enrolled]
  enrollment_dates <- patient_data$data$enrollment_date[1:n_enrolled]
  
  # find patients with censored followup up to the next accrual period
  i <- (tox_time > 30 | response == 0) & ((current_date - enrollment_dates) < 56)
  
  # find which patients are "censored" and assign weights accordingly
  if (sum(i) >= 1) {
    response[i] <- 0
    weights <- rep(1, length(response))
    weights[i] <- 30 / 56
  } else {
    weights <- rep(1, length(response))
  }
  
  # calculate mle for each partial ordering
  # and identify "best" partial order
  dose_assignment <- patient_data$data$dose_assignment[1:n_enrolled]
  
  a_mle <- numeric(M)
  log_lik <- numeric(M)
  
  for (m in 1:M) {
    # get the prior dlt probability corresponding to the dose and partial order for each observation
    partial_order <- po_mat[m,]
    alphas <- skeleton_mat[m,match(dose_assignment, partial_order)]
    
    # get mle and associated log likelihood
    optimized <- optimize_log_lik(response = response, alph = alphas, weights = weights)
    a_mle[m] <- optimized$maximum
    log_lik[m] <- optimized$objective
  }
  
  # find the partial order with maximum log likelihood
  # this assigns uniform prior for each order
  chosen_po <- which.is.max(log_lik)
  
  # get next recommended dose based on the partial ordering, 
  # skeleton, and maximum likelihood estimate
  po <- po_mat[chosen_po,]
  est_p <- skeleton_mat[chosen_po,]^a_mle[chosen_po]
  
  # return maximum dose under target P(DLT)
  if (est_p[1] <= target_pt) {
    next_dose <- po[max(which(est_p <= target_pt))]
  } else {
    next_dose <- 1
  }
  
  
  return(list(
    next_dose = next_dose,
    partial_order = chosen_po,
    a_mle = a_mle[chosen_po]
  ))
}

```

Check function with the following example data

```{r}
# sample data
patient_data <- list(
  data = data.frame(
    patient_id = c(1,2,3,4),
    enrollment_date = c(0, 0, 30, 30),
    dose_assignment = c(1, 1, 3, 3),
    tox = c(0, 0, 1, 1),
    time_to_tox = c(0, 0, 10, 50)
  ),
  n_enrolled = 4
)

cur_date <- 60
get_next_dose_po_tite_crm(patient_data, current_date = cur_date, po_mat = po_mat, skeleton_mat = skeleton_mat, target_p = 0.25)
```

Suppose both initial patients do not show DLT in the beginning. MLE cannot be calculated. (`a` is near boundary)

```{r}
# sample data
patient_data <- list(
  data = data.frame(
    patient_id = c(1,2),
    enrollment_date = c(0, 0),
    dose_assignment = c(1, 1),
    tox = c(0, 0),
    time_to_tox = c(5, 5)
  ),
  n_enrolled = 2
)

cur_date <- 60
get_next_dose_po_tite_crm(patient_data, current_date = cur_date, po_mat = po_mat, skeleton_mat = skeleton_mat, target_p = 0.25)
```

So far this is what the setup should look like

```{r}
# true toxicity matrix
true_tox_mat <- matrix(c(
  0.05, 0.09, 0.13, 
  0.15, 0.2 , 0.25,
  0.29, 0.32, 0.35
  ), byrow = TRUE, nrow = 3, ncol = 3)
true_tox_vec <- dlt_mat_to_vec <- as.vector(true_tox_mat)
names(true_tox_vec) <- c("P0.5+H2", "P0.5+H3", "P0.5+H5", 
                         "P0.75+H2", "P0.75+H3", "P0.75+H5",
                         "P1.0+H2", "P1.0+H3", "P1.0+H5")
print(true_tox_vec)

# number of partial orderings
M <- 4
# Number of treatment combinations
K <- length(true_tox_vec)

# matrix of partial ordering
po_mat <- matrix(NA, nrow = M, ncol = K)
po_mat[1,] <- c(1,2,3,4,5,6,7,8,9)
po_mat[2,] <- c(1,4,7,2,5,8,3,6,9)
po_mat[3,] <- c(1,2,4,3,5,7,6,8,9)
po_mat[4,] <- c(1,4,2,7,5,3,8,6,9)

print(po_mat)

# matrix of skeleton corresponding for each partial ordering
skeleton_mat <- matrix(
  rep(c(0.05, 0.08, 0.10, 0.13, 0.15, 0.18, 0.22, 0.25, 0.35), M),
  nrow = M, ncol = K, byrow = TRUE
)
print(skeleton_mat)
```

Now to write code for one round of simulation

```{r}
begin_sim <- function(
    true_tox_vec,
    po_mat,
    skeleton_mat,
    target_pt = 0.25,
    max_patients = 25,
    verbose = FALSE
) {
  
  # initiate patient data
  patient_data <- list(
    data = data.frame(
      patient_id = seq(1, max_patients),
      enrollment_date = NA,
      dose_assignment = NA,
      tox = NA,
      time_to_tox = NA
    ),
    n_enrolled = 0
  )
  
  # Initial phase should be algorithmic bc mle doesn't exist
  is_step1_phase <- TRUE
  current_date <- 0
  
  # begin with first dose
  next_dose <- 1
  zone <- 1 # for initial dose escalation
  treatment_esc_order <- c(
    1,2,4,3,5,7,6,8,9
  )
  
  if (verbose) print("Begin step 1...")
  while (is_step1_phase & patient_data$n_enrolled < max_patients) {
    
    # enroll 2 patients
    patient_data <- enroll_patient(
      patient_data, 
      enrollment_date = current_date, 
      assigned_dose = next_dose,
      true_tox_vec = true_tox_vec,
      n = 2,
      verbose = verbose
    )
    
    # set current date to next recruitment date
    current_date <- current_date + 30
    
    # get the uncensored response
    response <- patient_data$data$tox[1:patient_data$n_enrolled]
    tox_time <- patient_data$data$time_to_tox[1:patient_data$n_enrolled]
    enrollment_dates <- patient_data$data$enrollment_date[1:patient_data$n_enrolled]
    
    # find which patients are "censored" and assign weights accordingly
    censored <- enrollment_dates + tox_time > current_date
    if (any(censored)) {
      response[censored] <- 0
    }
    
    # decide if we should switch to crm phase
    if (length(unique(response)) > 1) {
      # switch if there are both non dlt and dlt
      if (verbose) {
        print("Both toxicity and non-toxicity observed")
      }
      is_step1_phase <- FALSE
    } else if (all(response == 1)) {
      # if all toxic response
      if (verbose) print("Both toxicity observed at beginning")
      
      sim_result <- list(
        data = patient_data$data,
        n_enrolled = patient_data$n_enrolled,
        MTD = 1
      )
      
      return(sim_result)
    } else {
      # if all no response
      if (zone < 9) {
        zone <- zone + 1
        next_dose <- treatment_esc_order[[zone]][sample(length(treatment_esc_order[[zone]]), 1)]
      } else {
        # it could be that there's delayed DLT for dose 9
        if (!all(tox_time == 0)) {
          # assume we wait 1 more month to wait for DLT to show up
          current_date <- 30
          is_step1_phase <- FALSE
        } else {
          # stop trial, return patients data
          sim_result <- list(
            data = patient_data$data,
            n_enrolled = patient_data$n_enrolled,
            MTD = 9
          )
          return(sim_result)
        }
        
      }
    }
  }
  
  # move onto stage 2
  if (verbose) print("Moving on to step 2...")
  
  # get next dose recommendation based on accumulated data
  po_tite_crm_out <- get_next_dose_po_tite_crm(
    patient_data = patient_data,
    current_date = current_date,
    po_mat = po_mat,
    skeleton_mat = skeleton_mat,
    target_pt = target_pt
  )
  
  next_dose <- po_tite_crm_out$next_dose
  
  # continue dose finding until 25 patients are enrolled
  while (patient_data$n_enrolled < max_patients) {
    patient_data <- enroll_patient(
      patient_data, 
      enrollment_date = current_date, 
      assigned_dose = next_dose,
      true_tox_vec = true_tox_vec,
      verbose = verbose
    )
    
    current_date <- current_date + 30
    
    if (patient_data$n_enrolled > max_patients) {
      stop("n_enrolled cannot be higher than max_patients")
    }
    
    if (patient_data$n_enrolled != max_patients) {
      po_tite_crm_out <- get_next_dose_po_tite_crm(
        patient_data = patient_data,
        current_date = current_date,
        po_mat = po_mat,
        skeleton_mat = skeleton_mat
      )
    } else {
      # get MTD
      po_tite_crm_out <- get_next_dose_po_tite_crm(
        patient_data = patient_data,
        current_date = current_date + 30,
        po_mat = po_mat,
        skeleton_mat = skeleton_mat
      )
    }
    
    next_dose <- po_tite_crm_out$next_dose
  }
  
  sim_result <- list(
    data = patient_data$data,
    n_enrolled = patient_data$n_enrolled,
    MTD = next_dose
  )
  
  return(sim_result)
  
}

set.seed(17)
sim_data <- begin_sim(
  true_tox_vec = true_tox_vec,
  po_mat = po_mat,
  skeleton_mat = skeleton_mat, 
  verbose = TRUE
)


```

Now write function that simulates a give number of times

```{r}
simulate_trials <- function(
    true_tox_vec,
    po_mat,
    skeleton_mat,
    target_pt = 0.25,
    N = 100,
    verbose = FALSE
) {
  operating_char <- list(
    MTD = integer(N),
    n_enrolled = integer(N),
    adverse_event_rate = numeric(N)
  )
  
  for (i in 1:N) {
    sim_data <- begin_sim(
      true_tox_vec = true_tox_vec,
      po_mat = po_mat,
      skeleton_mat = skeleton_mat,
      target_pt = 0.25,
      verbose = verbose
    )
    
    operating_char[["MTD"]][i] <- sim_data$MTD
    operating_char[["n_enrolled"]][i] <- sim_data$n_enrolled
    operating_char[["adverse_event_rate"]][i] <- mean(sim_data$data$tox)
  }
  
  return(operating_char)
}

# debug(simulate_trials)
```

Run simulation

```{r}
# true toxicity matrix
true_tox_mat <- matrix(c(
  0.05, 0.09, 0.13, 
  0.15, 0.2 , 0.25,
  0.29, 0.32, 0.35
  ), byrow = TRUE, nrow = 3, ncol = 3)
true_tox_vec <- dlt_mat_to_vec <- as.vector(true_tox_mat)
names(true_tox_vec) <- c("P0.5+H2", "P0.5+H3", "P0.5+H5", 
                         "P0.75+H2", "P0.75+H3", "P0.75+H5",
                         "P1.0+H2", "P1.0+H3", "P1.0+H5")
print(true_tox_vec)

# number of partial orderings
M <- 4
# Number of treatment combinations
K <- length(true_tox_vec)

# matrix of partial ordering
po_mat <- matrix(NA, nrow = M, ncol = K)
po_mat[1,] <- c(1,2,3,4,5,6,7,8,9)
po_mat[2,] <- c(1,4,7,2,5,8,3,6,9)
po_mat[3,] <- c(1,2,4,3,5,7,6,8,9)
po_mat[4,] <- c(1,4,2,7,5,3,8,6,9)

print(po_mat)

# matrix of skeleton corresponding for each partial ordering
skeleton_mat <- matrix(
  rep(c(0.05, 0.08, 0.10, 0.13, 0.15, 0.18, 0.22, 0.25, 0.35), M),
  nrow = M, ncol = K, byrow = TRUE
)
print(skeleton_mat)

opchar <- simulate_trials(
  true_tox_vec = true_tox_vec,
  po_mat = po_mat,
  skeleton_mat = skeleton_mat
)

true_tox_vec
table(opchar$MTD) / length(opchar$MTD)
```

```{r}
library(dfcrm)

po_index <- 3
trueprob <- true_tox_vec[po_mat[po_index,]]
prior <- skeleton_mat[po_index,]
target <- 0.25
n <- 25
x0 <- c(1,1,1,2,2,4,4,3,3,5,5,6,6,9,9)
nsim <- 1000
obswin <- 56
tgrp <- 30
rate <- 1.5
accrual <- "fixed"

# compare to my method

myout <- titesim(
  PI = trueprob, prior = prior, target = target, n = n, x0 = 1,
  nsim = nsim, obswin = obswin, tgrp = tgrp, rate = rate, accrual = accrual,
  seed = 123, restrict = FALSE
)

myout2 <- titesim(
  PI = trueprob, prior = prior, target = target, n = n, x0 = 1,
  nsim = nsim, obswin = obswin, tgrp = tgrp, rate = rate, accrual = accrual,
  seed = 123, restrict = TRUE
)


```

```{r}

```

